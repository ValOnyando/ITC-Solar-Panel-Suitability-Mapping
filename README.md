<div align="center">

# â˜€ï¸ Solar Panel Suitability Mapping â˜€ï¸

### *Identifying optimal rooftops for solar panel installation*

![Python](https://img.shields.io/badge/Python-3.8+-blue.svg)
![GeoPandas](https://img.shields.io/badge/GeoPandas-Vector%20Analysis-green.svg)
![License](https://img.shields.io/badge/license-MIT-blue.svg)

*A geospatial analysis project using Python and vector-based GIS technologies*

---

</div>

## ğŸ¯ Problem Statement

Identify optimal rooftops for solar panel installation by analyzing:
- ğŸ—ï¸ **Building geometry** (roof area, orientation, slope)
- â˜€ï¸ **Solar irradiance** (annual energy potential)
- ğŸŒ‘ **Shading effects** (nearby obstruction analysis)
- ğŸ’° **Economic viability** (ROI and cost-benefit analysis)

---

## ğŸ› ï¸ Technologies

<table>
<tr>
<td width="50%">

### ğŸ Core
- **Python 3.8+** - Main programming language

### ğŸ—ºï¸ Geospatial Libraries
- `geopandas` - Vector data manipulation
- `rasterio` - Raster data processing
- `shapely` - Geometric operations
- `folium` / `leafmap` - Interactive mapping
- `pyproj` - CRS transformations

</td>
<td width="50%">

### ğŸ“Š Data Analysis
- `numpy` - Numerical computing
- `pandas` - Data wrangling
- `scipy` - Scientific computing

### ğŸ“ˆ Visualization
- `matplotlib` - Static plots
- `seaborn` - Statistical visualization
- `plotly` - Interactive charts

</td>
</tr>
</table>

---

## ğŸ“ Project Structure

```
â”œâ”€â”€ data/                        # Cached API responses (not tracked, generated by scripts)
â”‚   â”œâ”€â”€ buildings.geojson       # Fetched from Microsoft Building Footprints API
â”‚   â”œâ”€â”€ osm_attributes.geojson  # Fetched from OpenStreetMap API
â”‚   â”œâ”€â”€ bag_3d.geojson          # Fetched from PDOK 3D BAG API (building heights)
â”‚   â””â”€â”€ solar_irradiance.json   # Fetched from PVGIS API
â”œâ”€â”€ src/                         # Core implementation modules (REQUIRED)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ data_acquisition.py     # API calls and data fetching
â”‚   â”œâ”€â”€ geometry.py             # Roof area, orientation, slope calculations
â”‚   â”œâ”€â”€ solar.py                # Energy production calculations
â”‚   â”œâ”€â”€ shading.py              # Shadow analysis algorithms
â”‚   â”œâ”€â”€ spatial_search.py       # Search algorithms (KD-tree, binary search, quicksort)
â”‚   â”œâ”€â”€ ranking.py              # Suitability scoring and ranking
â”‚   â”œâ”€â”€ api.py                  # REST API/geodata service
â”‚   â””â”€â”€ utils.py                # Helper functions
â”œâ”€â”€ tests/                       # Automated unit tests (REQUIRED - 5+ tests)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_data_acquisition.py # Test API calls
â”‚   â”œâ”€â”€ test_geometry.py        # Test geometric calculations
â”‚   â”œâ”€â”€ test_solar.py           # Test energy calculations
â”‚   â”œâ”€â”€ test_shading.py         # Test shadow analysis
â”‚   â”œâ”€â”€ test_spatial_search.py  # Test search algorithms (KD-tree, binary, quicksort)
â”‚   â”œâ”€â”€ test_ranking.py         # Test ranking algorithms
â”‚   â””â”€â”€ test_api.py             # Test API endpoints
â”œâ”€â”€ notebooks/                   # Jupyter notebooks (OPTIONAL - for exploration)
â”‚   â”œâ”€â”€ 01_data_exploration.ipynb      # Data acquisition and exploration
â”‚   â”œâ”€â”€ 02_algorithm_development.ipynb # Algorithm testing and refinement
â”‚   â””â”€â”€ 03_visualization_demo.ipynb    # Final visualizations
â”œâ”€â”€ outputs/                     # Generated results
â”‚   â”œâ”€â”€ maps/                   # Choropleth and interactive maps
â”‚   â”œâ”€â”€ reports/                # Analysis reports
â”‚   â””â”€â”€ figures/                # Plots and charts
â”œâ”€â”€ docs/                        # Documentation
â”‚   â””â”€â”€ api_documentation.md    # REST API documentation
â”œâ”€â”€ .gitignore                  # Git ignore file (includes data/ folder)
â”œâ”€â”€ requirements.txt            # Python dependencies (REQUIRED)
â”œâ”€â”€ setup.py                    # Package setup file (REQUIRED)
â”œâ”€â”€ pyproject.toml              # Alternative packaging configuration
â”œâ”€â”€ LICENSE                     # License file
â””â”€â”€ README.md                   # Project documentation (REQUIRED)
```

**Note:** 
- `data/` folder stores **cached API responses** - it's generated by running data acquisition scripts and should be in `.gitignore`
- `src/data_acquisition.py` contains all API request logic for fetching building footprints, OSM data, and PVGIS solar data
- `src/` and `tests/` contain production code and automated tests (required for our assignment)
- `notebooks/` are optional for exploration and demonstration purposes
- All code should be packaged using `setup.py` or `pyproject.toml` for deployment

---

## ğŸš€ Installation

### Prerequisites
- Python 3.8 or higher
- [Poetry](https://python-poetry.org/) (recommended) or pip

### Option 1: Using Poetry (Recommended)

Poetry provides better dependency management and isolated environments.

```bash
# Clone the repository
git clone https://github.com/ValOnyando/ITC-Solar-Panel-Suitability-Mapping.git
cd ITC-Solar-Panel-Suitability-Mapping

# Install Poetry (if not already installed)
curl -sSL https://install.python-poetry.org | python3 -
# Or on Windows (PowerShell):
# (Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py -

# Install all dependencies (including dev dependencies)
poetry install

# Or install without dev dependencies
poetry install --only main

# Activate the virtual environment
poetry shell
```

### Option 2: Using pip

```bash
# Clone the repository
git clone https://github.com/ValOnyando/ITC-Solar-Panel-Suitability-Mapping.git
cd ITC-Solar-Panel-Suitability-Mapping

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt
```

### Verify Installation

```bash
# Using Poetry
poetry run pytest

# Using pip
pytest
```

---

## ğŸ’» Usage

### Running the Pipeline

#### Using Poetry

```bash
# 1. Data Acquisition - Fetch building and solar data
poetry run python src/data_acquisition.py

# 2. Geometry Processing - Calculate roof properties
poetry run python src/geometry.py

# 3. Shading Analysis - Analyze shadows from nearby buildings
poetry run python src/shading.py

# 4. Solar Calculations - Calculate energy potential
poetry run python src/solar.py

# 5. Ranking - Rank buildings by suitability
poetry run python src/ranking.py

# 6. Run API server
poetry run solar-api
# Or: poetry run python src/api.py

# Run tests
poetry run pytest
poetry run pytest --cov=src  # With coverage

# Format code
poetry run black src/ tests/
```

#### Using pip

```bash
# Run scripts
python src/data_acquisition.py
python src/geometry.py
# ... etc

# Run tests
pytest
```

### Code Examples

### ğŸŒ¤ï¸ Fetch Solar Irradiance Data
```python
import requests

# Example: Fetch PVGIS data for a location
lat, lon = 52.0907, 5.1214  # Utrecht, Netherlands
url = f"https://re.jrc.ec.europa.eu/api/PVcalc?lat={lat}&lon={lon}&outputformat=json"
response = requests.get(url)
solar_data = response.json()
```

### ğŸ“ Calculate Roof Area
```python
import geopandas as gpd
from shapely.geometry import Polygon

# Load building footprints
buildings = gpd.read_file('data/buildings.geojson')

# Calculate roof areas
buildings['roof_area'] = buildings.geometry.area
```

### âš¡ Compute Solar Potential
```python
def calculate_solar_potential(area, irradiance, efficiency=0.18, shading=0.1):
    """
    Calculate solar energy potential for a rooftop.
    
    Parameters:
    - area: Roof area in mÂ²
    - irradiance: Annual solar irradiance in kWh/mÂ²/year
    - efficiency: Panel efficiency (default 18%)
    - shading: Shading factor 0-1 (default 0.1)
    
    Returns:
    - Annual energy production in kWh
    """
    return area * irradiance * efficiency * (1 - shading)

# Apply to buildings
buildings['energy_kwh'] = buildings.apply(
    lambda row: calculate_solar_potential(row['roof_area'], row['irradiance']),
    axis=1
)
```

---

## ğŸ“¦ Data Sources

| Source | Description | Format |
|--------|-------------|--------|
| ğŸ¢ **[Microsoft Building Footprints](https://github.com/microsoft/USBuildingFootprints)** | Building polygon geometries | GeoJSON |
| ğŸ—ºï¸ **[OpenStreetMap](https://www.openstreetmap.org/)** | Building attributes (height, type) | Open Buildings 2.5D |
| â˜€ï¸ **[PVGIS API](https://re.jrc.ec.europa.eu/pvg_tools/en/)** | Solar irradiance data | GeoJSON |
| ï¿½ï¸ **[PDOK 3D BAG](https://3dbag.nl/)** | 3D building data with roof heights | GeoJSON/CityJSON |

---

## ğŸ”¬ Methodology

### ğŸ§® Algorithms & Methods

<details open>
<summary><strong>1ï¸âƒ£ Geometric Analysis</strong></summary>

- ğŸ“ Roof area calculation using building footprint coordinates
- ğŸ§­ Roof orientation (aspect) determination
- ğŸ“ Roof slope angle analysis (for pitched roofs when available)
- ğŸ’¡ Implementation using OOP and Functional Programming paradigms

</details>

<details open>
<summary><strong>2ï¸âƒ£ Shadow Analysis</strong></summary>

- ğŸŒ‘ Nearby building obstruction modeling
- â° Temporal shading calculations

</details>

<details open>
<summary><strong>3ï¸âƒ£ Energy Calculation</strong></summary>

- âš¡ Solar potential estimation per building
- ğŸ”‹ Efficiency considerations

</details>

<details open>
<summary><strong>4ï¸âƒ£ Priority Ranking</strong></summary>

- ğŸ’° Cost-benefit analysis
- ğŸ“Š Return on investment (ROI) calculations

</details>

<details open>
<summary><strong>5ï¸âƒ£ Search Algorithms</strong></summary>

- ğŸŒ³ **KD-tree Spatial Index** - Efficient nearest neighbor and range queries (O(log n))
- ğŸ” **Binary Search** - Find buildings by score threshold (O(log n))
- âš¡ **Quicksort** - Sort buildings by suitability (O(n log n) average)
- ğŸ“Œ **Linear Search** - Find buildings by ID (O(n))
- ğŸ† **Top-K Selection** - Heap-based partial sort for priority lists (O(n log k))

</details>

### ğŸ“ Mathematical Formulation

> **Solar Potential Energy:**
$$E = A \times H \times \eta \times (1 - S)$$

Where:
- $E$ = Energy production (kWh)
- $A$ = Roof area (mÂ²)
- $H$ = Solar irradiance (kWh/mÂ²/year)
- $\eta$ = Panel efficiency (%)
- $S$ = Shading factor (0-1)

> **Return on Investment:**
$$ROI = \frac{E \times Price - Cost}{Cost}$$

Where:
- $Price$ = Energy price per kWh
- $Cost$ = Installation cost

### ğŸ”„ Processing Pipeline

```mermaid
graph TD
    A[ğŸ“¥ INPUT: Buildings + Solar Data] --> B[ğŸ“ STEP 1-2: Calculate Roof Area]
    B --> C[ğŸ§­ STEP 3: Calculate Orientation]
    C --> D[â˜€ï¸ STEP 4: Extract Solar Irradiance]
    D --> E[ğŸŒ‘ STEP 5: Calculate Shading]
    E --> F[âš¡ STEP 6: Calculate Energy Production]
    F --> G[ğŸ’° STEP 7: Calculate Economics]
    G --> H[ğŸ“Š STEP 8: Calculate Suitability Score]
    H --> I[ğŸ† STEP 9: Classify Buildings]
    I --> J[ğŸ“ˆ STEP 10: Visualize Results]
    J --> K[ğŸ“¤ OUTPUT: Suitability Map + Priority List]
```

<details>
<summary>View text-based pipeline</summary>

```
INPUT â†’ Buildings + Solar Data
  â†“
STEP 1-2: Calculate roof area (geometry)
  â†“
STEP 3: Calculate orientation (geometry)
  â†“
STEP 4: Extract solar irradiance (raster overlay)
  â†“
STEP 5: Calculate shading (spatial analysis)
  â†“
STEP 6: Calculate energy production (formula)
  â†“
STEP 7: Calculate economics (formula)
  â†“
STEP 8: Calculate suitability score (weighted combination)
  â†“
STEP 9: Classify buildings (categories)
  â†“
STEP 10: Visualize results (maps & charts)
  â†“
OUTPUT â†’ Suitability map + priority list
```

**Note:** Vector data is prioritized throughout the workflow, with raster operations used only when necessary for efficiency.

</details>

---

## ğŸ§ª Testing

Unit tests are implemented for critical components:

| Component | Status |
|-----------|--------|
| Roof area calculation algorithms | âœ… |
| Solar energy estimation functions | âœ… |
| Building ranking algorithms | âœ… |
| Geometric analysis functions | âœ… |
| Shading analysis algorithms | âœ… |

**Run tests:**
```bash
# Using Poetry
poetry run pytest
poetry run pytest -v                    # Verbose output
poetry run pytest --cov=src            # With coverage report
poetry run pytest --cov=src --cov-report=html  # HTML coverage report

# Using pip
pytest tests/ -v
pytest tests/ --cov=src
```

**Run specific test files:**
```bash
# Using Poetry
poetry run pytest tests/test_geometry.py
poetry run pytest tests/test_solar.py -v

# Using pip
pytest tests/test_geometry.py
```

---

## ğŸ“Š Visualizations

<table>
<tr>
<td width="33%">

### ğŸ—ºï¸ Choropleth Maps
- Solar potential by neighborhood
- Average suitability by district

</td>
<td width="33%">

### ğŸ¨ Interactive Maps
- Color-coded suitability scores
- Click-to-view building metrics
- Layered parameter visualization

</td>
<td width="33%">

### ğŸ“ˆ Analytical Plots
- Roof area vs. energy
- Orientation vs. irradiance
- Suitability histograms
- ROI distribution curves

</td>
</tr>
</table>

---

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## ğŸ¤ Contributing

Contributions are welcome! Here's how you can help:

1. ğŸ´ Fork the repository
2. ğŸ”¨ Create a feature branch (`git checkout -b feature/AmazingFeature`)
3. ğŸ’¾ Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. ğŸš€ Push to the branch (`git push origin feature/AmazingFeature`)
5. ğŸ“¬ Open a Pull Request

### Development Setup

```bash
# Clone your fork
git clone https://github.com/your-username/ITC-Solar-Panel-Suitability-Mapping.git

# Install with dev dependencies
poetry install

# Run tests before committing
poetry run pytest

# Format code
poetry run black src/ tests/

# Check code style
poetry run flake8 src/ tests/
```
4. ğŸ“¤ Push to the branch (`git push origin feature/AmazingFeature`)
5. ğŸ‰ Open a Pull Request

---

## ğŸ“§ Contact

ğŸ’¬ For questions or collaboration opportunities, please open an issue. 
You can also reach me at: valonyando@gmail.com - Vallary Onyando and Mo Anwar.

---

<div align="center">

**Made with â˜€ï¸ and ğŸ for a sustainable future**


</div>